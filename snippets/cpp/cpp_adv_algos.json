{
  "Dijkstra (Priority Queue)": {
    "prefix": "cpdijk",
    "body": [
      "// Dijkstra's Algorithm using priority queue",
      "vector<int> d(n, INF);",
      "priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
      "d[src] = 0;",
      "pq.push({0, src});",
      "while (!pq.empty()) {",
      "    auto [dist, u] = pq.top(); pq.pop();",
      "    if (dist > d[u]) continue;",
      "    for (auto [v, w] : adj[u]) {",
      "        if (d[u] + w < d[v]) {",
      "            d[v] = d[u] + w;",
      "            pq.push({d[v], v});",
      "        }",
      "    }",
      "}"
    ],
    "description": "Dijkstra's shortest path using min-heap",
    "category": "Graphs"
  },
  "Topological Sort (Kahn's Algorithm)": {
    "prefix": "cptopo",
    "body": [
      "// Topological Sort using Kahn's Algorithm",
      "vector<int> in_deg(n, 0);",
      "for (auto u : adj) for (auto v : u) in_deg[v]++;",
      "queue<int> q;",
      "for (int i = 0; i < n; ++i) if (in_deg[i] == 0) q.push(i);",
      "vector<int> topo;",
      "while (!q.empty()) {",
      "    int u = q.front(); q.pop();",
      "    topo.push_back(u);",
      "    for (int v : adj[u]) {",
      "        if (--in_deg[v] == 0) q.push(v);",
      "    }",
      "}"
    ],
    "description": "Topological Sort using Kahn's Algorithm",
    "category": "Graphs"
  },
  "KMP String Matching": {
    "prefix": "cpkmp",
    "body": [
      "// KMP Prefix Function",
      "vector<int> prefix(string s) {",
      "    int n = s.size();",
      "    vector<int> pi(n);",
      "    for (int i = 1; i < n; ++i) {",
      "        int j = pi[i - 1];",
      "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
      "        if (s[i] == s[j]) ++j;",
      "        pi[i] = j;",
      "    }",
      "    return pi;",
      "}"
    ],
    "description": "KMP Prefix Function for pattern matching",
    "category": "Strings"
  },
  "Binary Lifting (LCA)": {
    "prefix": "cplca",
    "body": [
      "// Binary Lifting for LCA",
      "int LOG = 20; // log2(n)",
      "vector<vector<int>> up(n, vector<int>(LOG));",
      "vector<int> depth(n);",
      "",
      "function<void(int, int)> dfs = [&](int u, int p) {",
      "    up[u][0] = p;",
      "    for (int i = 1; i < LOG; ++i)",
      "        up[u][i] = up[up[u][i - 1]][i - 1];",
      "    for (int v : adj[u]) {",
      "        if (v != p) {",
      "            depth[v] = depth[u] + 1;",
      "            dfs(v, u);",
      "        }",
      "    }",
      "};"
    ],
    "description": "Binary Lifting for Lowest Common Ancestor",
    "category": "Trees"
  },
  "Segment Tree (Lazy Propagation)": {
    "prefix": "cplazyseg",
    "body": [
      "// Segment Tree with Lazy Propagation",
      "void push(int v) {",
      "    // push updates to children",
      "    t[v*2] += lazy[v];",
      "    lazy[v*2] += lazy[v];",
      "    t[v*2+1] += lazy[v];",
      "    lazy[v*2+1] += lazy[v];",
      "    lazy[v] = 0;",
      "}",
      "",
      "void update(int v, int tl, int tr, int l, int r, int addend) {",
      "    if (l > r) return;",
      "    if (l == tl && r == tr) {",
      "        t[v] += addend;",
      "        lazy[v] += addend;",
      "    } else {",
      "        push(v);",
      "        int tm = (tl + tr) / 2;",
      "        update(v*2, tl, tm, l, min(r, tm), addend);",
      "        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);",
      "        t[v] = t[v*2] + t[v*2+1];",
      "    }",
      "}"
    ],
    "description": "Segment Tree with Lazy Propagation",
    "category": "Data Structures"
  },
  "SCC (Tarjan's Algorithm)": {
    "prefix": "cptarjan",
    "body": [
      "// Tarjan's Algorithm for Strongly Connected Components",
      "vector<int> tin(n, -1), low(n, -1), onStack(n);",
      "stack<int> stk;",
      "int timer = 0;",
      "",
      "function<void(int)> dfs = [&](int u) {",
      "    tin[u] = low[u] = timer++;",
      "    stk.push(u);",
      "    onStack[u] = 1;",
      "    for (int v : adj[u]) {",
      "        if (tin[v] == -1) {",
      "            dfs(v);",
      "            low[u] = min(low[u], low[v]);",
      "        } else if (onStack[v]) {",
      "            low[u] = min(low[u], tin[v]);",
      "        }",
      "    }",
      "    if (tin[u] == low[u]) {",
      "        // Found SCC root",
      "        while (true) {",
      "            int v = stk.top(); stk.pop();",
      "            onStack[v] = 0;",
      "            // process component",
      "            if (v == u) break;",
      "        }",
      "    }",
      "};"
    ],
    "description": "Tarjan's algorithm for SCC",
    "category": "Graphs"
  },
  "Fenwick Tree (BIT)": {
    "prefix": "cpbit",
    "body": [
      "// Fenwick Tree (Binary Indexed Tree)",
      "vector<int> bit(n+1);",
      "auto update = [&](int i, int val) {",
      "    for (++i; i <= n; i += i & -i) bit[i] += val;",
      "};",
      "auto query = [&](int i) {",
      "    int res = 0;",
      "    for (++i; i > 0; i -= i & -i) res += bit[i];",
      "    return res;",
      "};"
    ],
    "description": "1D Fenwick Tree (BIT)",
    "category": "Data Structures"
  },
  "Extended Euclidean Algorithm": {
    "prefix": "cpextgcd",
    "body": [
      "// Extended Euclidean Algorithm",
      "int extgcd(int a, int b, int &x, int &y) {",
      "    if (b == 0) { x = 1; y = 0; return a; }",
      "    int x1, y1;",
      "    int d = extgcd(b, a % b, x1, y1);",
      "    x = y1;",
      "    y = x1 - (a / b) * y1;",
      "    return d;",
      "}"
    ],
    "description": "Extended Euclidean Algorithm",
    "category": "Number Theory"
  },
  "Chinese Remainder Theorem (CRT)": {
    "prefix": "cpcrt",
    "body": [
      "// Chinese Remainder Theorem",
      "int crt(vector<int> r, vector<int> m) {",
      "    int r0 = 0, m0 = 1;",
      "    for (int i = 0; i < r.size(); ++i) {",
      "        int r1 = r[i], m1 = m[i];",
      "        int p, q;",
      "        int g = extgcd(m0, m1, p, q);",
      "        if ((r1 - r0) % g) return -1;",
      "        int lcm = m0 / g * m1;",
      "        r0 += ((r1 - r0) / g * p % (m1 / g)) * m0;",
      "        r0 = (r0 % lcm + lcm) % lcm;",
      "        m0 = lcm;",
      "    }",
      "    return r0;",
      "}"
    ],
    "description": "Chinese Remainder Theorem",
    "category": "Number Theory"
  },
  "Z Algorithm (Pattern Matching)": {
    "prefix": "cpzalgo",
    "body": [
      "// Z Algorithm for pattern matching",
      "vector<int> z_function(string s) {",
      "    int n = s.length();",
      "    vector<int> z(n);",
      "    int l = 0, r = 0;",
      "    for (int i = 1; i < n; ++i) {",
      "        if (i <= r)",
      "            z[i] = min(r - i + 1, z[i - l]);",
      "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
      "            ++z[i];",
      "        if (i + z[i] - 1 > r)",
      "            l = i, r = i + z[i] - 1;",
      "    }",
      "    return z;",
      "}"
    ],
    "description": "Z algorithm for string matching",
    "category": "Strings"
  }
}