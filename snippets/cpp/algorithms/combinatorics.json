[
  {
    "prefix": "cpcombpermute",
    "description": "Next permutation using STL",
    "category": "Combinatorics",
    "body": [
      "sort($1.begin(), $1.end());",
      "do {",
      "    // use $1",
      "} while (next_permutation($1.begin(), $1.end()));"
    ]
  },
  {
    "prefix": "cpcombcombmod",
    "description": "nCr % MOD using factorials",
    "category": "Combinatorics",
    "body": [
      "const int MOD = $1;",
      "const int N = $2;",
      "vector<long long> fact(N), inv(N);",
      "",
      "long long modpow(long long a, long long b, long long m) {",
      "    long long res = 1;",
      "    while (b) {",
      "        if (b & 1) res = res * a % m;",
      "        a = a * a % m;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "void precompute() {",
      "    fact[0] = inv[0] = 1;",
      "    for (int i = 1; i < N; ++i) {",
      "        fact[i] = fact[i - 1] * i % MOD;",
      "        inv[i] = modpow(fact[i], MOD - 2, MOD);",
      "    }",
      "}",
      "",
      "long long C(int n, int r) {",
      "    if (r > n || r < 0) return 0;",
      "    return fact[n] * inv[r] % MOD * inv[n - r] % MOD;",
      "}"
    ]
  },
  {
    "prefix": "cpcombmodinv",
    "description": "Modular inverse using Fermat's Little Theorem",
    "category": "Combinatorics",
    "body": [
      "long long modinv(long long a, long long m) {",
      "    long long res = 1, b = m - 2;",
      "    while (b) {",
      "        if (b & 1) res = res * a % m;",
      "        a = a * a % m;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}"
    ]
  },
  {
    "prefix": "cpcombfactpre",
    "description": "Precompute factorials and inverse factorials",
    "category": "Combinatorics",
    "body": [
      "const int N = $1; // up to n",
      "vector<long long> fact(N), inv(N);",
      "",
      "long long modpow(long long a, long long b, long long m) {",
      "    long long res = 1;",
      "    while (b) {",
      "        if (b & 1) res = res * a % m;",
      "        a = a * a % m;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "void initFact(int MOD) {",
      "    fact[0] = inv[0] = 1;",
      "    for (int i = 1; i < N; ++i) {",
      "        fact[i] = fact[i - 1] * i % MOD;",
      "        inv[i] = modpow(fact[i], MOD - 2, MOD);",
      "    }",
      "}"
    ]
  },
  {
    "prefix": "cpcombstarsbars",
    "description": "Stars and Bars: ways to split n into k non-negative integers",
    "category": "Combinatorics",
    "body": [
      "// Total ways = C(n + k - 1, k - 1)",
      "long long stars_and_bars(int n, int k) {",
      "    return C(n + k - 1, k - 1);",
      "}"
    ]
  },
  {
    "prefix": "cpcombderangement",
    "description": "Derangement formula D(n)",
    "category": "Combinatorics",
    "body": [
      "vector<long long> derange(n+1);",
      "derange[0] = 1; derange[1] = 0;",
      "for (int i = 2; i <= n; ++i)",
      "    derange[i] = (i - 1) * (derange[i - 1] + derange[i - 2]) % MOD;"
    ]
  },
  {
    "prefix": "cpcombpermrep",
    "description": "n^k permutations with repetition",
    "category": "Combinatorics",
    "body": [
      "long long perm_with_repetition(int n, int k, int MOD) {",
      "    return modpow(n, k, MOD);",
      "}"
    ]
  },
  {
    "prefix": "cpcombbell",
    "description": "Bell numbers (number of ways to partition a set)",
    "category": "Combinatorics",
    "body": [
      "vector<vector<long long>> bell(n+1, vector<long long>(n+1));",
      "bell[0][0] = 1;",
      "for (int i = 1; i <= n; ++i) {",
      "    bell[i][0] = bell[i-1][i-1];",
      "    for (int j = 1; j <= i; ++j) {",
      "        bell[i][j] = (bell[i-1][j-1] + bell[i][j-1]) % MOD;",
      "    }",
      "}"
    ]
  }
]